using System;
using System.Collections.Generic;

namespace CSharpFP_Demo
{
    // Totality - функция должна возвращать значение для всего диапазона входных значений.
    // Несоблюдение этого принципа при написании функций приводит трудно понимаемому коду
    // и увеличивает вероятность багов. Поэтому лучше писать львиную долю функций, придерживаясь
    // данного принципа.

    // Теперь пара примеров
    public class Totality
    {
        // Нарушение Totality - функция не возвращает значение,
        // а передает управление обратно с помощью механизма исключений.
        // Можно избежать данное нарушение, если использовать тип Result вместо исключений,
        // поменяв тип возвращаемого значения на Result.
        public int NonTotalFunction_1(int x)
        {
            throw new Exception();
        }

        // Нарушение Totality - функция не возвращает значение,
        // а осуществляет завершение текущего процесса.
        // Можно избежать, запретив подобные вызовы, по крайней мере в глубине программы.
        // Лучше всего такие вызовы перемещать в самые внешние слои.
        public int NonTotalFunction_2(int x)
        {
            Environment.Exit(1);
            return 0;
        }

        // Нарушение Totality - функция не возвращает значение для всего диапазона
        // входных значений. Вместо этого иногда она не возвращает управление вызвавшему
        // из-за бесконечного цикла.
        // Можно избежать, запретив подобные вызовы, по крайней мере в глубине программы.
        // Лучше всего такие вызовы перемещать в самые внешние слои.
        public int NonTotalFunction_3(int x)
        {
            if (x < 0)
            {
                while (true) { }
            }

            return x;
        }

        // Зачастую даже из сигнатуры видно, что принцип не соблюдается, например:
        public T First<T>(IEnumerable<T> enumerable) { throw new NotImplementedException("TODO"); }

        // В данном случае функция заявляет, что для любого IEnumerable<T> сможет нам вернуть первый его элемент.
        // Однако же понятно, что не для всех IEnumerable<T> это возможно. Контрпример - пустой IEnumerable<T>.
        // Для исправления ситуации, можно использовать Option<T> вместо T в качестве возвращаемого значения.



        // Еще одним пример нарушения принципа:
        public class Config { /* ... */ }
        public Config ParseConfig(string configString) { throw new NotImplementedException("TODO"); }
        
        // Очевидно, что не для любой строки можно получить экземпляр Config'а. В данном случае можно вернуть
        // Result<Config, TError>, чтобы избежать нарушения Totality.
    }
}
