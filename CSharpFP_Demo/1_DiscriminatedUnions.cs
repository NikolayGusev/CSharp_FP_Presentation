using NUnit.Framework;
using System;

namespace CSharpFP_Demo
{
    [TestFixture]
    public class DiscriminatedUnions
    {
        // Для начала определим тип Shape и двух его наследников - Rectange и Circle
        public class Shape_ { }
        public class Rectangle_ : Shape_
        {
            public double Height { get; set; }
            public double Width { get; set; }
        }
        public class Circle_ : Shape_
        {
            public double Radius { get; set; }
        }

        // Затем напишем метод, который работает с любыми Shape'ами и выдает площадь фигуры.
        // В данном методе происходит проверка на тип переданной фигуры и в зависимости от него используется 
        // та или иная формула. 
        //
        // Подобные методы довольно часто встречаются, когда мы не хотим заносить сложные зависимости в наши
        // классы и пользоваться полиморфизмом. Например, данный метод может обращаться к серверу для расчета площади и т.п.
        // Не хотелось бы усложнять класс Shape и его наследников лишними подробностями.
        public double GetArea_(Shape_ shape)
        {
            var rectangle = shape as Rectangle_;
            if (rectangle != null) return rectangle.Height * rectangle.Width;

            var circle = shape as Circle_;
            if (circle != null) return Math.PI * Math.Pow(circle.Radius, 2);

            throw new NotSupportedException(shape.GetType().Name);
        }

        // Проверим, что наш метод действительно работает
        [Test]
        public void GetArea1_SwitchingExample()
        {
            Shape_ shape1 = new Rectangle_ { Width = 3, Height = 5 };
            Assert.That(GetArea_(shape1), Is.EqualTo(15));

            Shape_ shape2 = new Circle_ { Radius = 1 };
            Assert.That(GetArea_(shape2), Is.EqualTo(Math.PI));
        }

        // Но вот незадача - кто-то другой решил расширить иерархию классов и добавить к ней еще один вид 
        // фигуры - Triangle
        public class Triangle_ : Shape_
        {
            public double Side { get; set; }
        }

        // И разумеется, забыл обновить метод GetArea, который теперь иногда выбрасывает исключения.
        [Test]
        public void GetArea1_TriangleException()
        {
            Shape_ shape = new Triangle_ { Side = 10 };
            Assert.Throws<NotSupportedException>(() => GetArea_(shape));
        }

        // Компилятор нам совсем не помогает бороться с такими проблемами. Перейдем теперь к варианту с Discriminated Unions

        // Discriminated Unions похожи на иерархии классов с одним уровнем наследования, но являются закрытыми 
        // (т.е. не предполагают дополнительного наследования).
        // Вместо наследования для расширения возможностей программы используется композиция (composition over inheritance).
        // 
        // Так же Discriminated Unions можно представлять себе как enum значения, для каждого кейса которых можно добавлять 
        // произвольные данные. Так например для enum значений Shape есть два возможный кейса - Rectangle и Circle, каждый со
        // своими свойствами.

        // Предлагаемое решение для использования Discriminated Unions предполагает использование кодогенерации. Определение самого
        // Union'а задается вручную. Такие же фигуры как и раньше в виде Discriminated Union можно задать так:

        [UnionBase]
        public abstract partial class Shape { }
        public partial class Rectangle : Shape
        {
            public double Height { get; set; }
            public double Width { get; set; }
        }
        public partial class Circle : Shape
        {
            public double Radius { get; set; }
        }

        // Дальше запускается кодогенерация и дополняет Shape новыми методами Match и Do.

        #region Autogenerated
        public abstract partial class Shape
        {
            public T Match<T>(Func<Rectangle, T> rectangle,
                              Func<Circle, T> circle)
            {
                var r = this as Rectangle;
                if (r != null) return rectangle(r);

                var c = this as Circle;
                if (c != null) return circle(c);

                // Недостижимый код!
                throw new NotSupportedException();
            }

            public void Do(Action<Rectangle> rectangle,
                           Action<Circle> circle)
            {
                var r = this as Rectangle;
                if (r != null) rectangle(r);

                var c = this as Circle;
                if (c != null) circle(c);

                // Недостижимый код!
                throw new NotSupportedException();
            }

            internal abstract void Seal(); // Не даем наследоваться от Shape.
                                           // Кейсы закрываем через “partial sealed class Rectangle/Circle”
        }

        public partial class Rectangle
        {
            internal override void Seal() { }
        }

        public partial class Circle
        {
            internal override void Seal() { }
        }
        #endregion

        // Перепишем метод GetArea с помощью метода Match
        public double GetArea(Shape shape)
        {
            return shape.Match(rectangle: r => r.Height * r.Width,
                               circle:    c => Math.PI * Math.Pow(c.Radius, 2));
        }

        // Проверим, что наш метод выдает те же результаты
        [Test]
        public void GetArea1_UnionMatchExample()
        {
            Shape shape1 = new Rectangle { Width = 3, Height = 5 };
            Assert.That(GetArea(shape1), Is.EqualTo(15));

            Shape shape2 = new Circle { Radius = 1 };
            Assert.That(GetArea(shape2), Is.EqualTo(Math.PI));
        }

        // Что же произойдет, когда к Discriminated Union добавится новый кейс?
        // Раскомментируйте определение класса Triangle. Далее чтобы проэмулировать работу
        // кодогенерации (перегенерировать код), закомментируйте регион #region Autogenerated, предсталенный ранее,
        // и раскомментируйте регион Autogenerated for Triangle. После этого попробуйте собрать проект.


        //public partial class Triangle : Shape
        //{
        //    public double Side { get; set; }
        //}

        #region Autogenerated with Triangle
        //public abstract partial class Shape
        //{
        //    public T Match<T>(Func<Rectangle, T> rectangle,
        //                      Func<Circle, T> circle,
        //                      Func<Triangle, T> triangle)
        //    {
        //        var r = this as Rectangle;
        //        if (r != null) return rectangle(r);

        //        var c = this as Circle;
        //        if (c != null) return circle(c);

        //        var t = this as Triangle;
        //        if (t != null) return triangle(t);

        //        // Недостижимый код!
        //        throw new NotSupportedException();
        //    }

        //    public void Do(Action<Rectangle> rectangle,
        //                   Action<Circle> circle,
        //                   Action<Triangle> triangle)
        //    {
        //        var r = this as Rectangle;
        //        if (r != null) rectangle(r);

        //        var c = this as Circle;
        //        if (c != null) circle(c);

        //        var t = this as Triangle;
        //        if (t != null) triangle(t);

        //        // Недостижимый код!
        //        throw new NotSupportedException();
        //    }

        //    internal abstract void Seal(); // Не даем наследоваться от Shape.
        //                                   // Кейсы закрываем через “partial sealed class Rectangle/Circle”
        //}

        //public partial class Rectangle
        //{
        //    internal override void Seal() { }
        //}

        //public partial class Circle
        //{
        //    internal override void Seal() { }
        //}

        //public partial class Triangle
        //{
        //    internal override void Seal() { }
        //}
        #endregion


        // Предсказуемо наш метод GetArea перестанет компилироваться, ведь теперь в Discriminated Union'е 3 кейса,
        // а не два, как раньше! 
        // Ошибка компиляции решает важную задачу - пропадает возможность допустить ошибку, и забыть при добавлении нового
        // кейса обновить методы, которые используют метод Match. В результате разработчик разгружается от нудного поиска 
        // мест, где же еще используется type switching.

        // Примечания:

        // К сожалению, в отличие от Pattern Matching'а, предлагаемого в качестве встроенной конструкции в язык (например в F#),
        // в данной реализации нет возможности в одной из ветвей рассмотреть несколько кейсов:

        // F# 
        // match x with
        // |Case1 |Case2 -> "Case1 or Case2"
        // |Case3        -> "Case3"

        // Для ускорения работы сгенерированных Discriminated Unions можно посмотреть, во что они превращаются в IL при использовании
        // их в F#: https://fsharpforfunandprofit.com/posts/fsharp-decompiled/
        // Вместо проверок по типу, для каждого типа вводится поле Tag по корому и производится проверка.
    }
}
